import os
import random
import json
import uuid
from faker import Faker
from datetime import datetime, timedelta
from openai import AzureOpenAI

# Load API key from external file
***REMOVED***_path = "C:/Users/FredrikVillo/repos/TestDataGeneration/***REMOVED***.txt"
with open(***REMOVED***_path, "r") as f:
    ***REMOVED*** = f.read().strip()

# Azure OpenAI client setup
client = AzureOpenAI(
    ***REMOVED***=***REMOVED***,
    api_version="2025-01-01-preview",
    azure_endpoint="https://azureopenai-sin-dev.openai.azure.com"
)

fake = Faker()

# Static list for import modified values
IMPORT_MODIFIED_CHOICES = [
    "initialImport",
    "dataImportCompleted",
    "syncUpdate",
    "validationFailed",
    "fileImportCompleted",
    "importFileProcessingError"
]

# Function to call Azure OpenAI API
def call_openai(prompt, model="gpt-4o", max_tokens=100, temperature=0.7):
    try:
        response = client.chat.completions.create(
            model=model,
            messages=[{"role": "user", "content": prompt}],
            max_tokens=max_tokens,
            temperature=temperature
        )
        return response.choices[0].message.content.strip()
    except Exception as e:
        print(f"Error calling OpenAI API: {e}")
        return None

# Clean text response
def clean_response(text):
    if text:
        return text.replace('`', '').replace('*', '').replace('"', '').strip()
    return text

# Batch generate department names with country suffix
def generate_department_names_batch(n=10):
    countries = ["Norway", "Sweden", "UK", "India"]
    prompt = (
        f"Generate exactly {n} unique, creative, and professional names for corporate departments in a mid-sized company. "
        "List them without explanations, separated by commas. "
        "Do not include any special characters or numbers like '1', '2', etc. "
        "Ensure the list contains exactly {n} names."
    )
    print(f"üîç Sending prompt to OpenAI: {prompt}")
    response = call_openai(prompt, max_tokens=200 + n * 10, temperature=0.7)
    if response:
        print(f"üîç Received response from OpenAI: {response}")
        names = [clean_response(name.strip()) for name in response.split(',') if name.strip()]
        if len(names) >= n:
            print("‚úÖ GPT generated department names.")
            return [f"{name} {random.choice(countries)}" for name in names[:n]]
        else:
            print(f"‚ö†Ô∏è Insufficient names generated by GPT. Expected {n}, got {len(names)}. Retrying...")
            missing_count = n - len(names)
            additional_prompt = (
                f"Generate {missing_count} more unique, creative, and professional names for corporate departments. "
                "List them without explanations, separated by commas."
            )
            additional_response = call_openai(additional_prompt, max_tokens=200, temperature=0.7)
            if additional_response:
                additional_names = [clean_response(name.strip()) for name in additional_response.split(',') if name.strip()]
                names.extend(additional_names[:missing_count])
            if len(names) < n:
                print(f"‚ö†Ô∏è Still insufficient names after retry. Filling the gap with Faker.")
                names.extend([f"{fake.bs().title()} {random.choice(countries)}" for _ in range(n - len(names))])
            return [f"{name} {random.choice(countries)}" for name in names[:n]]
    else:
        print("‚ö†Ô∏è No response from OpenAI. Falling back to Faker.")
        return [f"{fake.bs().title()} {random.choice(countries)}" for _ in range(n)]

# Generate LDAP DN string consistently
def generate_directory_dn_fast(department_name):
    safe_name = department_name.replace(" ", "").replace("&", "And").replace("/", "-")
    return f"CN={safe_name},OU=Departments,DC=example,DC=com"

# Generate organization data
def generate_organization_table(num_orgs=10):
    organizations = []
    org_ids = list(range(1, num_orgs + 1))

    dept_names = generate_department_names_batch(num_orgs)

    for i in range(num_orgs):
        org_id = org_ids[i]
        name = dept_names[i]

        motherorg = random.choice(org_ids[:i]) if i > 0 and random.random() < 0.3 else None

        created_date = fake.date_time_between(start_date='-5y', end_date='-1y')
        modified_date = fake.date_time_between(start_date=created_date, end_date='now')
        directory_modified = fake.date_time_between(start_date=modified_date - timedelta(days=90), end_date=modified_date)

        directory_dn = generate_directory_dn_fast(name)
        import_modified = random.choice(IMPORT_MODIFIED_CHOICES)

        organization = {
            "ORGANIZATION": org_id,
            "NAME": name,
            "MOTHERORG": motherorg,
            "DISABLED": 1 if random.random() < 0.1 else 0,
            "CREATED": created_date.strftime("%Y-%m-%d %H:%M:%S"),
            "MODIFIED": modified_date.strftime("%Y-%m-%d %H:%M:%S"),
            "DIRECTORYDN": directory_dn,
            "DIRECTORYMODIFIED": directory_modified.strftime("%Y-%m-%d %H:%M:%S"),
            "SORTORDER": (i + 1) * 10,
            "UNIQUE_IMPORT_ID": uuid.uuid4().hex[:8],
            "IMPORT_MODIFIED": import_modified,
            "ORGANIZATION_LEVEL": random.randint(1, 5),
            "GUID": str(uuid.uuid4())
        }

        organizations.append(organization)

    return organizations

# Generate and save to JSON
output_path = "json/organization_data_with_gpt.json"
org_data = generate_organization_table(100)

with open(output_path, "w", encoding="utf-8") as f:
    json.dump(org_data, f, indent=2)

print(f"‚úÖ Organization data generated and saved to '{output_path}'")
